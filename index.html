<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>rd1.io</title>
<style>
  @font-face {
    font-family: 'GOST B';
    src: url('gost-b.woff') format('woff');
    font-weight: normal;
    font-style: normal;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    display: flex; min-height: 100vh; background: #eef1f5;
    color: #1e293b;
  }

  /* ---- Sidebar ---- */
  #sidebar {
    width: 340px; min-width: 340px;
    background: linear-gradient(180deg, #f8fafc 0%, #ffffff 100%);
    border-right: 1px solid #e2e8f0;
    padding: 24px 20px;
    overflow-y: auto;
    display: flex; flex-direction: column; gap: 7px;
  }

  #sidebar h2 {
    font-size: 17px; font-weight: 700; color: #0f172a;
    margin-bottom: 4px;
    padding-left: 10px;
    border-left: 3px solid #3b82f6;
    line-height: 1.3;
  }

  #sidebar h3 {
    font-size: 10.5px; font-weight: 600; color: #94a3b8;
    text-transform: uppercase; letter-spacing: 0.8px;
    margin-top: 14px; margin-bottom: 4px;
    padding-bottom: 5px;
    border-bottom: 1px solid #e2e8f0;
  }

  /* ---- Fields ---- */
  .field {
    display: flex; align-items: center; gap: 8px;
    padding: 2px 0;
  }

  .field label {
    flex: 1; font-size: 13px; font-weight: 450; color: #475569;
    white-space: nowrap;
  }

  .field input[type="number"] {
    width: 72px; padding: 6px 8px;
    border: 1px solid #cbd5e1; border-radius: 6px;
    font-size: 13px; font-weight: 500; text-align: right;
    color: #1e293b; background: #fff;
    transition: border-color 0.15s, box-shadow 0.15s;
  }

  .field input[type="number"]:focus {
    outline: none; border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59,130,246,0.12);
  }

  .field select {
    padding: 6px 8px;
    border: 1px solid #cbd5e1; border-radius: 6px;
    font-size: 13px; font-weight: 500;
    color: #1e293b; background: #fff;
    transition: border-color 0.15s, box-shadow 0.15s;
  }

  .field select:focus {
    outline: none; border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59,130,246,0.12);
  }

  .field .unit {
    font-size: 11px; font-weight: 500; color: #94a3b8;
    width: 24px; flex-shrink: 0;
  }

  /* ---- Checkboxes ---- */
  .chk-field {
    padding: 3px 0;
  }

  .chk-field input[type="checkbox"] {
    width: 16px; height: 16px;
    accent-color: #3b82f6;
    cursor: pointer; flex-shrink: 0;
    border-radius: 3px;
  }

  .chk-field label {
    cursor: pointer;
  }

  /* ---- Textarea ---- */
  #taNotes {
    width: 100%; padding: 8px 10px;
    border: 1px solid #cbd5e1; border-radius: 6px;
    font-size: 12px; font-family: inherit; color: #1e293b;
    background: #fff; resize: vertical; line-height: 1.5;
    transition: border-color 0.15s, box-shadow 0.15s;
  }
  #taNotes:focus {
    outline: none; border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59,130,246,0.12);
  }

  /* ---- Buttons ---- */
  .btn-pdf {
    margin-top: 10px; padding: 11px 0; width: 100%;
    background: #3b82f6; color: #fff;
    border: none; border-radius: 8px;
    font-size: 14px; font-weight: 600; cursor: pointer;
    letter-spacing: 0.2px;
    box-shadow: 0 1px 3px rgba(59,130,246,0.3);
    transition: background 0.15s, box-shadow 0.15s, transform 0.1s;
  }
  .btn-pdf:hover {
    background: #2563eb;
    box-shadow: 0 2px 8px rgba(59,130,246,0.35);
  }
  .btn-pdf:active {
    background: #1d4ed8; transform: translateY(1px);
    box-shadow: 0 0 2px rgba(59,130,246,0.3);
  }
  .btn-pdf:disabled {
    opacity: 0.6; cursor: default; transform: none;
  }
  .btn-pdf.secondary {
    background: #64748b;
    box-shadow: 0 1px 3px rgba(100,116,139,0.3);
  }
  .btn-pdf.secondary:hover {
    background: #475569;
    box-shadow: 0 2px 8px rgba(100,116,139,0.35);
  }
  .btn-pdf.secondary:active {
    background: #334155;
  }

  /* ---- Canvas area ---- */
  #main {
    flex: 1; display: flex; flex-direction: column; align-items: center;
    padding: 20px; overflow: auto; gap: 24px;
    background:
      radial-gradient(circle, #d1d5db 0.7px, transparent 0.7px);
    background-size: 16px 16px;
    background-color: #eef1f5;
  }

  canvas {
    background: #fff;
    border-radius: 4px;
    box-shadow: 0 2px 12px rgba(0,0,0,0.08), 0 0 0 1px rgba(0,0,0,0.04);
  }
</style>
</head>
<body>

<div id="sidebar">
  <h2 id="title">rd1.io</h2>

  <h3 id="secGab">---</h3>
  <div class="field">
    <label id="lbW">---</label>
    <input id="inW" type="number" value="400" min="100" max="2000" step="10">
    <span class="unit" id="uW"></span>
  </div>
  <div class="field">
    <label id="lbH">---</label>
    <input id="inH" type="number" value="900" min="200" max="3000" step="10">
    <span class="unit" id="uH"></span>
  </div>
  <div class="field">
    <label id="lbD">---</label>
    <input id="inD" type="number" value="200" min="100" max="1500" step="10">
    <span class="unit" id="uD"></span>
  </div>

  <h3 id="secDet">---</h3>
  <div class="field">
    <label id="lbThickness">---</label>
    <input id="inThickness" type="number" value="1.2" min="0.5" max="5" step="0.1">
    <span class="unit" id="uThickness"></span>
  </div>
  <div class="field">
    <label id="lbFlange">---</label>
    <input id="inFlange" type="number" value="10" min="2" max="30" step="1">
    <span class="unit" id="uFlange"></span>
  </div>
  <div class="field">
    <label id="lbDoorInset">---</label>
    <input id="inDoorInset" type="number" value="15" min="5" max="50" step="1">
    <span class="unit" id="uDoorInset"></span>
  </div>
  <div class="field">
    <label id="lbHandleH">---</label>
    <input id="inHandleH" type="number" value="60" min="20" max="200" step="5">
    <span class="unit" id="uHandleH"></span>
  </div>
  <div class="field">
    <label id="lbVentSlots">---</label>
    <input id="inVentSlots" type="number" value="5" min="0" max="15" step="1">
    <span class="unit" id="uVentSlots"></span>
  </div>
  <div class="field">
    <label id="lbCableHoles">---</label>
    <input id="inCableHoles" type="number" value="3" min="0" max="10" step="1">
    <span class="unit" id="uCableHoles"></span>
  </div>
  <div class="field">
    <label id="lbMountGap">---</label>
    <input id="inMountGap" type="number" value="40" min="10" max="100" step="5">
    <span class="unit" id="uMountGap"></span>
  </div>
  <div class="field">
    <label id="lbHinges">---</label>
    <input id="inHinges" type="number" value="3" min="2" max="6" step="1">
    <span class="unit" id="uHinges"></span>
  </div>

  <h3 id="secShow">---</h3>
  <div class="field chk-field">
    <label id="lbShowDoor">---</label>
    <input type="checkbox" id="chkDoor" checked>
  </div>
  <div class="field chk-field">
    <label id="lbShowPanel">---</label>
    <input type="checkbox" id="chkPanel" checked>
  </div>
  <div class="field chk-field">
    <label id="lbShowHandle">---</label>
    <input type="checkbox" id="chkHandle" checked>
  </div>
  <div class="field chk-field">
    <label id="lbShowHinges">---</label>
    <input type="checkbox" id="chkHinges" checked>
  </div>
  <div class="field">
    <label id="lbFlatMode">---</label>
    <select id="selFlat">
      <option value="off">Не показывать</option>
      <option value="u" selected>U-образная</option>
      <option value="cross">Крестообразная</option>
    </select>
  </div>

  <h3 id="secNotes">---</h3>
  <textarea id="taNotes" rows="8" spellcheck="false">1. Материал корпуса — сталь 08ПС, толщина 1,2 мм.
2. Материал двери — сталь 08ПС, толщина 1,5 мм.
3. Монтажная панель — сталь 08ПС оцинк., толщина 2 мм.
4. Сварные швы зачистить. Острые кромки притупить R0,5.
5. Обезжирить, грунтовать ГФ-021, окрасить порошковой краской RAL 7035 толщиной 60–80 мкм.
6. Степень защиты — IP54.
7. Петли и замок — нержавеющая сталь.</textarea>

  <button id="btnPdfDrawing" class="btn-pdf">---</button>
  <button id="btnPdfFlat" class="btn-pdf secondary">---</button>
</div>

<div id="main">
  <canvas id="cDrawing"></canvas>
  <canvas id="cFlat"></canvas>
</div>

<script>
const cvsDraw = document.getElementById('cDrawing');
const ctxDraw = cvsDraw.getContext('2d');
const cvsFlat = document.getElementById('cFlat');
const ctxFlat = cvsFlat.getContext('2d');

let ctx; // active context, switched during render

const SCALE = 0.48;
const GAP = 75;
const MARGIN = 55;
const DIM_OFFSET = 44;
const DEPTH_SCALE = 0.5;
const ANG = Math.PI / 6;
const cosA = Math.cos(ANG);
const sinA = Math.sin(ANG);

let W, H, D, FLANGE, THICKNESS, DOOR_INSET, HANDLE_H, VENT_SLOTS, CABLE_HOLES, MOUNT_GAP, HINGE_COUNT;
let BA; // bend allowance per 90-degree bend
let DOOR_W, DOOR_H, PANEL_W, PANEL_H;
let SHOW_DOOR, SHOW_PANEL, SHOW_HANDLE, SHOW_HINGES;
let FLAT_MODE; // 'off', 'u', 'cross'
let NOTES_TEXT;
let sW, sH, sD, sDI, sFL, sBA;
let sDoorW, sDoorH, sPanelW, sPanelH;
let dxDepth, dyDepth;
let frontX, frontY, sideX, sideY, isoX, isoY;
let row2Y, doorViewX, panelViewX, notesX;
let flatBodyX, flatDoorX, flatPanelX;
let sFlatBodyW, sFlatBodyH;
let flatRow2Y, flatFloorX, flatCeilX;
let sTopW, sTopH;
let sFlatDoorW, sFlatDoorH;

function readInputs() {
  W           = +document.getElementById('inW').value || 400;
  H           = +document.getElementById('inH').value || 900;
  D           = +document.getElementById('inD').value || 350;
  THICKNESS   = +document.getElementById('inThickness').value || 1.2;
  FLANGE      = +document.getElementById('inFlange').value || 10;
  DOOR_INSET  = +document.getElementById('inDoorInset').value || 15;
  HANDLE_H    = +document.getElementById('inHandleH').value || 60;
  VENT_SLOTS  = +document.getElementById('inVentSlots').value || 0;
  CABLE_HOLES = +document.getElementById('inCableHoles').value || 0;
  MOUNT_GAP   = +document.getElementById('inMountGap').value || 40;
  HINGE_COUNT = +document.getElementById('inHinges').value || 3;

  DOOR_W = W - 2 * DOOR_INSET;
  DOOR_H = H - 2 * DOOR_INSET;
  PANEL_W = W - 2 * MOUNT_GAP;
  PANEL_H = H - 2 * MOUNT_GAP;

  SHOW_DOOR = document.getElementById('chkDoor').checked;
  SHOW_PANEL = document.getElementById('chkPanel').checked;
  SHOW_HANDLE = document.getElementById('chkHandle').checked;
  SHOW_HINGES = document.getElementById('chkHinges').checked;
  FLAT_MODE = document.getElementById('selFlat').value;
  NOTES_TEXT = document.getElementById('taNotes').value;

  BA = (Math.PI / 2) * (THICKNESS + 0.33 * THICKNESS);

  sW = W * SCALE;
  sH = H * SCALE;
  sD = D * SCALE;
  sDI = DOOR_INSET * SCALE;
  sFL = FLANGE * SCALE;
  sBA = BA * SCALE;
  sDoorW = DOOR_W * SCALE;
  sDoorH = DOOR_H * SCALE;
  sPanelW = PANEL_W * SCALE;
  sPanelH = PANEL_H * SCALE;

  dxDepth = sD * DEPTH_SCALE * cosA;
  dyDepth = sD * DEPTH_SCALE * sinA;

  // Drawing sheet layout
  frontX = MARGIN + DIM_OFFSET + 5;
  frontY = MARGIN + 25;
  sideX = frontX + sW + GAP;
  sideY = frontY;
  isoX = sideX + sD + GAP;
  isoY = frontY + dyDepth / 2;

  row2Y = frontY + sH + DIM_OFFSET * 2 + 55;
  doorViewX = frontX;
  panelViewX = doorViewX + (SHOW_DOOR ? sDoorW + GAP + DIM_OFFSET : 0);

  let lastViewRight = MARGIN;
  if (SHOW_DOOR) lastViewRight = doorViewX + sDoorW + DIM_OFFSET;
  if (SHOW_PANEL) lastViewRight = Math.max(lastViewRight, panelViewX + sPanelW + DIM_OFFSET);
  notesX = lastViewRight + GAP * 0.4;

  // Flat sheet layout (includes flanges + bend allowance)
  const flba = FLANGE + BA;
  sFlatBodyW = (W + 2 * D + 2 * flba) * SCALE;
  sFlatBodyH = FLAT_MODE === 'cross'
    ? (H + 2 * D + 2 * flba) * SCALE
    : (H + 2 * FLANGE) * SCALE;

  sFlatDoorW = (DOOR_W + 2 * flba) * SCALE;
  sFlatDoorH = (DOOR_H + 2 * flba) * SCALE;

  flatBodyX = MARGIN + DIM_OFFSET + 5;
  flatDoorX = flatBodyX + sFlatBodyW + GAP + DIM_OFFSET;
  flatPanelX = flatDoorX + (SHOW_DOOR ? sFlatDoorW + GAP + DIM_OFFSET : 0);

  sTopW = (W + 2 * flba) * SCALE;
  sTopH = (D + 2 * flba) * SCALE;
  flatRow2Y = MARGIN + 25 + sFlatBodyH + DIM_OFFSET * 2 + 55;
  flatFloorX = flatBodyX;
  flatCeilX = flatFloorX + sTopW + GAP + DIM_OFFSET;
}

// ============================================================
// DRAWING PRIMITIVES
// ============================================================
function line(x1, y1, x2, y2) {
  ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
}
function rect(x, y, w, h) { ctx.strokeRect(x, y, w, h); }
function dashedRect(x, y, w, h, dash) {
  ctx.setLineDash(dash || [6,3]); ctx.strokeRect(x, y, w, h); ctx.setLineDash([]);
}
function circle(cx, cy, r) {
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
}
function filledCircle(cx, cy, r) {
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
}
function arrowHead(x, y, angle, size) {
  ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
  ctx.beginPath(); ctx.moveTo(0,0);
  ctx.lineTo(-size, -size*0.35); ctx.lineTo(-size, size*0.35);
  ctx.closePath(); ctx.fill(); ctx.restore();
}
function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y); ctx.arcTo(x + w, y, x + w, y + r, r);
  ctx.lineTo(x + w, y + h - r); ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx.lineTo(x + r, y + h); ctx.arcTo(x, y + h, x, y + h - r, r);
  ctx.lineTo(x, y + r); ctx.arcTo(x, y, x + r, y, r);
  ctx.closePath();
}

// ============================================================
// DIMENSION LINES
// ============================================================
function dimH(x1, x2, y, objY, label) {
  const dir = y > objY ? 1 : -1;
  ctx.save();
  ctx.strokeStyle = '#555'; ctx.lineWidth = 0.6;
  ctx.font = '14px GOST B, sans-serif';
  line(x1, objY + 4*dir, x1, y + 3*dir);
  line(x2, objY + 4*dir, x2, y + 3*dir);
  line(x1, y, x2, y);
  ctx.fillStyle = '#555';
  arrowHead(x1, y, 0, 6); arrowHead(x2, y, Math.PI, 6);
  const midX = (x1+x2)/2, tw = ctx.measureText(label).width;
  ctx.fillStyle='#fff'; ctx.fillRect(midX-tw/2-2, y-13, tw+4, 12);
  ctx.fillStyle='#333'; ctx.textAlign='center'; ctx.textBaseline='bottom';
  ctx.fillText(label, midX, y-2);
  ctx.restore();
}
function dimV(y1, y2, x, objX, label) {
  const dir = x < objX ? -1 : 1;
  ctx.save();
  ctx.strokeStyle = '#555'; ctx.lineWidth = 0.6;
  ctx.font = '14px GOST B, sans-serif';
  line(objX - 4*dir, y1, x - 3*dir, y1);
  line(objX - 4*dir, y2, x - 3*dir, y2);
  line(x, y1, x, y2);
  ctx.fillStyle = '#555';
  arrowHead(x, y1, Math.PI/2, 6); arrowHead(x, y2, -Math.PI/2, 6);
  const midY = (y1+y2)/2, tw = ctx.measureText(label).width;
  ctx.save(); ctx.translate(x, midY); ctx.rotate(-Math.PI/2);
  ctx.fillStyle='#fff'; ctx.fillRect(-tw/2-2, -13, tw+4, 12);
  ctx.fillStyle='#333'; ctx.textAlign='center'; ctx.textBaseline='bottom';
  ctx.fillText(label, 0, -2);
  ctx.restore(); ctx.restore();
}

// ============================================================
// ISOMETRIC HELPERS
// ============================================================
function isoProject(x3, y3, z3) {
  return [x3 + z3*DEPTH_SCALE*cosA, y3 - z3*DEPTH_SCALE*sinA];
}
function isoLine(x1,y1,z1, x2,y2,z2) {
  const [a,b]=isoProject(x1,y1,z1), [c,d]=isoProject(x2,y2,z2);
  line(isoX+a, isoY+b, isoX+c, isoY+d);
}
function isoPoly(pts, fill) {
  const p = pts.map(v => { const [a,b]=isoProject(v[0],v[1],v[2]); return [isoX+a, isoY+b]; });
  ctx.beginPath(); ctx.moveTo(p[0][0],p[0][1]);
  for (let i=1;i<p.length;i++) ctx.lineTo(p[i][0],p[i][1]);
  ctx.closePath();
  if (fill) { ctx.fillStyle=fill; ctx.fill(); }
  ctx.stroke();
}
function isoEllipseTop(cx3, cz3, r) {
  const [a,b]=isoProject(cx3,0,cz3);
  ctx.beginPath(); ctx.save();
  ctx.translate(isoX+a, isoY+b); ctx.scale(1, 0.55);
  ctx.arc(0,0,r,0,Math.PI*2);
  ctx.restore(); ctx.stroke();
}

// ============================================================
// DRAWING SHEET VIEWS
// ============================================================
function drawFront() {
  ctx.save();
  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Вид спереди', frontX + sW/2, frontY - 15);
  ctx.lineWidth = 2; ctx.strokeStyle = '#222';
  rect(frontX, frontY, sW, sH);
  ctx.lineWidth = 0.7; ctx.strokeStyle = '#555';
  rect(frontX+sFL, frontY+sFL, sW-2*sFL, sH-2*sFL);
  if (SHOW_DOOR) {
    ctx.lineWidth = 1.3; ctx.strokeStyle = '#333';
    rect(frontX+sDI, frontY+sDI, sW-2*sDI, sH-2*sDI);
    if (SHOW_HINGES) {
      ctx.lineWidth = 0.8; ctx.strokeStyle = '#555';
      const dT = frontY+sDI, dB = frontY+sH-sDI, dH = dB-dT;
      for (let i=0; i<HINGE_COUNT; i++) {
        const hy = dT + dH*(i+1)/(HINGE_COUNT+1);
        ctx.fillStyle='#ccc';
        ctx.fillRect(frontX+sDI-3, hy-6, 6, 12);
        ctx.strokeRect(frontX+sDI-3, hy-6, 6, 12);
      }
    }
    if (SHOW_HANDLE) {
      ctx.lineWidth=1; ctx.strokeStyle='#444';
      const hx = frontX+sW-sDI-16, hy = frontY+sH/2 - HANDLE_H*SCALE/2;
      const hhs = HANDLE_H*SCALE;
      ctx.fillStyle='#ddd'; ctx.fillRect(hx,hy,7,hhs); ctx.strokeRect(hx,hy,7,hhs);
      ctx.lineWidth=0.7;
      const lx=hx+0.5, ly=hy+hhs+8;
      ctx.fillStyle='#bbb'; ctx.fillRect(lx,ly,6,9);
      ctx.strokeStyle='#444'; ctx.strokeRect(lx,ly,6,9);
      ctx.fillStyle='#444'; filledCircle(lx+3,ly+3,1.3);
      ctx.fillRect(lx+2.3, ly+4, 1.4, 3);
    }
    ctx.lineWidth=0.6; ctx.strokeStyle='#777';
    const vTop = frontY+sH-sDI-45, vW = sW*0.4, vX = frontX+(sW-vW)/2;
    for (let i=0; i<VENT_SLOTS; i++) {
      const vy = vTop+i*7;
      line(vX,vy,vX+vW,vy); line(vX,vy+2.5,vX+vW,vy+2.5);
    }
  }
  if (SHOW_PANEL) {
    const mg = MOUNT_GAP*SCALE;
    ctx.lineWidth=0.5; ctx.strokeStyle='#bbb';
    dashedRect(frontX+mg, frontY+mg, sW-2*mg, sH-2*mg, [4,3]);
  }
  dimV(frontY, frontY+sH, frontX-DIM_OFFSET, frontX, String(H));
  dimH(frontX, frontX+sW, frontY+sH+DIM_OFFSET, frontY+sH, String(W));
  ctx.restore();
}

function drawSide() {
  ctx.save();
  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Вид сбоку', sideX + sD/2, sideY - 15);
  ctx.lineWidth = 2; ctx.strokeStyle = '#222';
  rect(sideX, sideY, sD, sH);
  ctx.lineWidth = 0.7; ctx.strokeStyle = '#555';
  line(sideX+sFL, sideY, sideX+sFL, sideY+sH);
  line(sideX+sD-sFL, sideY, sideX+sD-sFL, sideY+sH);
  line(sideX, sideY+sFL, sideX+sD, sideY+sFL);
  line(sideX, sideY+sH-sFL, sideX+sD, sideY+sH-sFL);
  dimH(sideX, sideX+sD, sideY+sH+DIM_OFFSET, sideY+sH, String(D));
  ctx.restore();
}

function drawIso() {
  ctx.save();
  ctx.lineWidth=1.2; ctx.strokeStyle='#222';
  isoPoly([[sW,0,0],[sW,0,sD],[sW,sH,sD],[sW,sH,0]], '#c0c0c0');
  isoPoly([[0,0,0],[sW,0,0],[sW,0,sD],[0,0,sD]], '#ddd');
  ctx.lineWidth=0.7; ctx.strokeStyle='#888';
  const cSt = sW/(CABLE_HOLES+1);
  for (let i=0;i<CABLE_HOLES;i++) isoEllipseTop(cSt*(i+1), sD*0.5, 5);
  ctx.lineWidth=1.4; ctx.strokeStyle='#222';
  isoPoly([[0,0,0],[sW,0,0],[sW,sH,0],[0,sH,0]], '#e8e8e8');
  ctx.lineWidth=0.6; ctx.strokeStyle='#aaa';
  isoPoly([[sFL,sFL,0],[sW-sFL,sFL,0],[sW-sFL,sH-sFL,0],[sFL,sH-sFL,0]], null);
  if (SHOW_DOOR) {
    ctx.lineWidth=1; ctx.strokeStyle='#666';
    isoPoly([[sDI,sDI,0],[sW-sDI,sDI,0],[sW-sDI,sH-sDI,0],[sDI,sH-sDI,0]], null);
    if (SHOW_HINGES) {
      ctx.lineWidth=0.7; ctx.strokeStyle='#888';
      const idT=sDI, idH=sH-2*sDI;
      for (let i=0;i<HINGE_COUNT;i++) {
        const hy=idT+idH*(i+1)/(HINGE_COUNT+1);
        isoPoly([[sDI-2,hy-5,0],[sDI+2,hy-5,0],[sDI+2,hy+5,0],[sDI-2,hy+5,0]], '#ccc');
      }
    }
    if (SHOW_HANDLE) {
      ctx.lineWidth=0.8; ctx.strokeStyle='#777';
      const ihx=sW-sDI-12, ihy=sH/2-HANDLE_H*SCALE/2, ihh=HANDLE_H*SCALE;
      isoPoly([[ihx,ihy,0],[ihx+5,ihy,0],[ihx+5,ihy+ihh,0],[ihx,ihy+ihh,0]], '#ddd');
      const ilx=ihx+0.5, ily=ihy+ihh+6;
      isoPoly([[ilx,ily,0],[ilx+4,ily,0],[ilx+4,ily+7,0],[ilx,ily+7,0]], '#bbb');
    }
    ctx.lineWidth=0.4; ctx.strokeStyle='#999';
    const vT=sH-sDI-35, vL=sW*0.28, vR=sW*0.72;
    for (let i=0;i<VENT_SLOTS;i++) {
      const vy=vT+i*5;
      isoLine(vL,vy,0,vR,vy,0); isoLine(vL,vy+2,0,vR,vy+2,0);
    }
  }
  ctx.lineWidth=0.8; ctx.strokeStyle='#999';
  isoLine(0,0,0,sW,0,0); isoLine(0,sFL,0,sW,sFL,0);
  isoLine(0,0,0,0,sH,0); isoLine(sFL,0,0,sFL,sH,0);
  ctx.lineWidth=0.5; ctx.strokeStyle='#aaa';
  isoLine(sW,0,sFL,sW,sH,sFL); isoLine(sW,0,sD-sFL,sW,sH,sD-sFL);
  isoLine(0,0,sFL,sW,0,sFL); isoLine(0,0,sD-sFL,sW,0,sD-sFL);
  ctx.restore();
}

function drawDoor() {
  if (!SHOW_DOOR) return;
  const ox = doorViewX, oy = row2Y;
  ctx.save();
  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Дверь', ox + sDoorW/2, oy - 15);
  ctx.lineWidth = 2; ctx.strokeStyle = '#222';
  rect(ox, oy, sDoorW, sDoorH);
  if (SHOW_HINGES) {
    ctx.lineWidth = 0.8; ctx.strokeStyle = '#555';
    for (let i = 0; i < HINGE_COUNT; i++) {
      const hy = oy + sDoorH * (i+1) / (HINGE_COUNT+1);
      ctx.fillStyle = '#ccc';
      ctx.fillRect(ox - 3, hy - 7, 6, 14);
      ctx.strokeRect(ox - 3, hy - 7, 6, 14);
    }
  }
  if (SHOW_HANDLE) {
    ctx.lineWidth = 1; ctx.strokeStyle = '#444';
    const hx = ox + sDoorW - 16, hy = oy + sDoorH/2 - HANDLE_H*SCALE/2;
    const hhs = HANDLE_H * SCALE;
    ctx.fillStyle = '#ddd'; ctx.fillRect(hx, hy, 7, hhs); ctx.strokeRect(hx, hy, 7, hhs);
    ctx.lineWidth = 0.7;
    const lx = hx + 0.5, ly = hy + hhs + 8;
    ctx.fillStyle = '#bbb'; ctx.fillRect(lx, ly, 6, 9);
    ctx.strokeStyle = '#444'; ctx.strokeRect(lx, ly, 6, 9);
    ctx.fillStyle = '#444'; filledCircle(lx+3, ly+3, 1.3);
    ctx.fillRect(lx+2.3, ly+4, 1.4, 3);
  }
  ctx.lineWidth = 0.6; ctx.strokeStyle = '#777';
  const vW = sDoorW * 0.45, vX = ox + (sDoorW - vW) / 2;
  const vTop = oy + sDoorH - 45;
  for (let i = 0; i < VENT_SLOTS; i++) {
    const vy = vTop + i * 7;
    line(vX, vy, vX + vW, vy); line(vX, vy + 2.5, vX + vW, vy + 2.5);
  }
  dimV(oy, oy + sDoorH, ox - DIM_OFFSET, ox, String(DOOR_H));
  dimH(ox, ox + sDoorW, oy + sDoorH + DIM_OFFSET * 0.5, oy + sDoorH, String(DOOR_W));
  ctx.restore();
}

function drawPanel() {
  if (!SHOW_PANEL) return;
  const ox = panelViewX, oy = row2Y;
  ctx.save();
  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Монтажная панель', ox + sPanelW/2, oy - 15);
  ctx.lineWidth = 2; ctx.strokeStyle = '#222';
  rect(ox, oy, sPanelW, sPanelH);
  ctx.lineWidth = 0.8; ctx.strokeStyle = '#666';
  const holeInset = 12, hr = 3;
  const corners = [
    [ox + holeInset, oy + holeInset], [ox + sPanelW - holeInset, oy + holeInset],
    [ox + holeInset, oy + sPanelH - holeInset], [ox + sPanelW - holeInset, oy + sPanelH - holeInset]
  ];
  for (const [cx, cy] of corners) { circle(cx, cy, hr); filledCircle(cx, cy, 1); }
  ctx.lineWidth = 0.7; ctx.strokeStyle = '#999'; ctx.setLineDash([5, 3]);
  const railInset = 20, railSpacing = 55;
  const railCount = Math.max(1, Math.floor((sPanelH - 2 * railInset) / railSpacing));
  for (let i = 0; i < railCount; i++) {
    const ry = oy + railInset + i * railSpacing + railSpacing / 2;
    if (ry > oy + sPanelH - railInset) break;
    line(ox + railInset, ry, ox + sPanelW - railInset, ry);
    line(ox + railInset, ry + 4, ox + sPanelW - railInset, ry + 4);
  }
  ctx.setLineDash([]);
  dimV(oy, oy + sPanelH, ox - DIM_OFFSET, ox, String(PANEL_H));
  dimH(ox, ox + sPanelW, oy + sPanelH + DIM_OFFSET * 0.5, oy + sPanelH, String(PANEL_W));
  ctx.restore();
}

// ============================================================
// NOTES VIEW
// ============================================================
const NOTES_W = 340;
const NOTES_PAD = 16;
const NOTES_LINE_H = 17;
const NOTES_R = 8;

function drawNotes() {
  if (!NOTES_TEXT || !NOTES_TEXT.trim()) return;
  const ox = notesX, oy = row2Y;
  ctx.save();
  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Указания', ox + NOTES_W / 2, oy - 15);
  const lines = NOTES_TEXT.split('\n');
  ctx.font = '13px GOST B, sans-serif';
  ctx.textAlign = 'left'; ctx.textBaseline = 'top';
  const wrappedLines = [];
  for (const rawLine of lines) {
    if (!rawLine.trim()) { wrappedLines.push(''); continue; }
    const words = rawLine.split(' ');
    let cur = '';
    for (const w of words) {
      const test = cur ? cur + ' ' + w : w;
      if (ctx.measureText(test).width > NOTES_W - 2 * NOTES_PAD && cur) {
        wrappedLines.push(cur); cur = w;
      } else { cur = test; }
    }
    if (cur) wrappedLines.push(cur);
  }
  const boxH = Math.max(wrappedLines.length * NOTES_LINE_H + 2 * NOTES_PAD, 80);
  roundRect(ox, oy, NOTES_W, boxH, NOTES_R);
  ctx.fillStyle = '#f4f5f7'; ctx.fill();
  ctx.fillStyle = '#333';
  for (let i = 0; i < wrappedLines.length; i++) {
    ctx.fillText(wrappedLines[i], ox + NOTES_PAD, oy + NOTES_PAD + i * NOTES_LINE_H);
  }
  ctx.restore();
}

function getNotesHeight() {
  if (!NOTES_TEXT || !NOTES_TEXT.trim()) return 0;
  ctx.save();
  ctx.font = '13px GOST B, sans-serif';
  const lines = NOTES_TEXT.split('\n');
  let count = 0;
  for (const rawLine of lines) {
    if (!rawLine.trim()) { count++; continue; }
    const words = rawLine.split(' ');
    let cur = '';
    for (const w of words) {
      const test = cur ? cur + ' ' + w : w;
      if (ctx.measureText(test).width > NOTES_W - 2 * NOTES_PAD && cur) {
        count++; cur = w;
      } else { cur = test; }
    }
    if (cur) count++;
  }
  ctx.restore();
  return Math.max(count * NOTES_LINE_H + 2 * NOTES_PAD, 80);
}

// ============================================================
// FLAT PATTERN: BODY SHELL
// ============================================================
function drawFlatBody() {
  if (FLAT_MODE === 'off') return;
  const flatY = MARGIN + 25;
  const ox = flatBodyX, oy = flatY;
  const sFlBa = sFL + sBA;
  const flba = FLANGE + BA;
  const totalW = W + 2 * D + 2 * flba;
  const baLabel = Math.round(BA * 10) / 10;
  ctx.save();

  if (FLAT_MODE === 'u') {
    const totalH = H + 2 * FLANGE;
    ctx.font = 'bold 16px GOST B, sans-serif';
    ctx.fillStyle = '#222'; ctx.textAlign = 'center';
    ctx.fillText('Развёртка корпуса (U)', ox + sFlatBodyW / 2, oy - 15);

    ctx.lineWidth = 2; ctx.strokeStyle = '#222';
    rect(ox, oy, sFlatBodyW, sFlatBodyH);

    // Bend lines at flba offset from edges
    const bend1 = ox + sFlBa + sD;
    const bend2 = bend1 + sW;
    ctx.lineWidth = 0.9; ctx.strokeStyle = '#c00';
    ctx.setLineDash([12, 4, 2, 4]);
    line(bend1, oy, bend1, oy + sFlatBodyH);
    line(bend2, oy, bend2, oy + sFlatBodyH);
    ctx.setLineDash([]);

    ctx.font = '11px GOST B, sans-serif';
    ctx.fillStyle = '#c00'; ctx.textAlign = 'center';
    ctx.fillText('сгиб', bend1, oy - 4);
    ctx.fillText('сгиб', bend2, oy - 4);

    // Flange zone lines (top/bottom)
    ctx.lineWidth = 0.5; ctx.strokeStyle = '#999'; ctx.setLineDash([4, 3]);
    line(ox, oy + sFL, ox + sFlatBodyW, oy + sFL);
    line(ox, oy + sFlatBodyH - sFL, ox + sFlatBodyW, oy + sFlatBodyH - sFL);
    ctx.setLineDash([]);

    // Dimensions: total
    dimH(ox, ox + sFlatBodyW, oy + sFlatBodyH + DIM_OFFSET, oy + sFlatBodyH, totalW.toFixed(1));
    dimV(oy, oy + sFlatBodyH, ox - DIM_OFFSET, ox, totalH.toFixed(1));

    // Sub-dimensions horizontal
    const subDimY = oy + sFlatBodyH + DIM_OFFSET * 0.4;
    dimH(ox, ox + sFlBa, subDimY, oy + sFlatBodyH, flba.toFixed(1));
    dimH(ox + sFlBa, bend1, subDimY, oy + sFlatBodyH, String(D));
    dimH(bend1, bend2, subDimY, oy + sFlatBodyH, String(W));
    dimH(bend2, bend2 + sD, subDimY, oy + sFlatBodyH, String(D));
    dimH(bend2 + sD, ox + sFlatBodyW, subDimY, oy + sFlatBodyH, flba.toFixed(1));

  } else if (FLAT_MODE === 'cross') {
    const totalH = H + 2 * D + 2 * flba;
    ctx.font = 'bold 16px GOST B, sans-serif';
    ctx.fillStyle = '#222'; ctx.textAlign = 'center';
    ctx.fillText('Развёртка корпуса (крест)', ox + sFlatBodyW / 2, oy - 15);

    const bL = ox + sFlBa + sD;
    const bR = bL + sW;
    const bT = oy + sFlBa + sD;
    const bB = bT + sH;

    // Cross-shaped outline
    ctx.lineWidth = 2; ctx.strokeStyle = '#222';
    ctx.beginPath();
    ctx.moveTo(bL, oy);
    ctx.lineTo(bR, oy);
    ctx.lineTo(bR, bT);
    ctx.lineTo(ox + sFlatBodyW, bT);
    ctx.lineTo(ox + sFlatBodyW, bB);
    ctx.lineTo(bR, bB);
    ctx.lineTo(bR, oy + sFlatBodyH);
    ctx.lineTo(bL, oy + sFlatBodyH);
    ctx.lineTo(bL, bB);
    ctx.lineTo(ox, bB);
    ctx.lineTo(ox, bT);
    ctx.lineTo(bL, bT);
    ctx.closePath();
    ctx.stroke();

    // 4 bend lines
    ctx.lineWidth = 0.9; ctx.strokeStyle = '#c00';
    ctx.setLineDash([12, 4, 2, 4]);
    line(bL, bT, bL, bB);
    line(bR, bT, bR, bB);
    line(bL, bT, bR, bT);
    line(bL, bB, bR, bB);
    ctx.setLineDash([]);

    ctx.font = '11px GOST B, sans-serif';
    ctx.fillStyle = '#c00'; ctx.textAlign = 'center';
    ctx.fillText('сгиб', bL, bT - 4);
    ctx.fillText('сгиб', bR, bT - 4);
    ctx.fillText('сгиб', (bL + ox) / 2, bT + 12);
    ctx.fillText('сгиб', (bR + ox + sFlatBodyW) / 2, bT + 12);

    // Flange lines on outer edges of flaps
    ctx.lineWidth = 0.5; ctx.strokeStyle = '#999'; ctx.setLineDash([4, 3]);
    line(bL, oy + sFlBa, bR, oy + sFlBa);
    line(bL, oy + sFlatBodyH - sFlBa, bR, oy + sFlatBodyH - sFlBa);
    line(ox + sFlBa, bT, ox + sFlBa, bB);
    line(ox + sFlatBodyW - sFlBa, bT, ox + sFlatBodyW - sFlBa, bB);
    ctx.setLineDash([]);

    // Cable holes in top flap
    ctx.lineWidth = 0.6; ctx.strokeStyle = '#999'; ctx.setLineDash([3, 2]);
    const cS = sW / (CABLE_HOLES + 1);
    for (let i = 0; i < CABLE_HOLES; i++) circle(bL + cS * (i + 1), oy + sFlBa + sD / 2, 7);
    ctx.setLineDash([]);

    // Labels for flaps
    ctx.font = '11px GOST B, sans-serif';
    ctx.fillStyle = '#888'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('потолок', (bL + bR) / 2, (oy + sFlBa + bT) / 2);
    ctx.fillText('пол', (bL + bR) / 2, (bB + oy + sFlatBodyH - sFlBa) / 2);
    ctx.fillText('боковина', (ox + sFlBa + bL) / 2, (bT + bB) / 2);
    ctx.fillText('боковина', (bR + ox + sFlatBodyW - sFlBa) / 2, (bT + bB) / 2);
    ctx.fillText('задняя стенка', (bL + bR) / 2, (bT + bB) / 2);

    // Dimensions
    dimH(ox, ox + sFlatBodyW, oy + sFlatBodyH + DIM_OFFSET, bB, totalW.toFixed(1));
    dimV(oy, oy + sFlatBodyH, ox - DIM_OFFSET, bL, totalH.toFixed(1));

    const subDimY = oy + sFlatBodyH + DIM_OFFSET * 0.4;
    dimH(ox, ox + sFlBa, subDimY, bB, flba.toFixed(1));
    dimH(ox + sFlBa, bL, subDimY, bB, String(D));
    dimH(bL, bR, subDimY, bB, String(W));
    dimH(bR, bR + sD, subDimY, bB, String(D));
    dimH(bR + sD, ox + sFlatBodyW, subDimY, bB, flba.toFixed(1));

    const subDimX = ox - DIM_OFFSET * 0.35;
    dimV(oy, oy + sFlBa, subDimX, bL, flba.toFixed(1));
    dimV(oy + sFlBa, bT, subDimX, bL, String(D));
    dimV(bT, bB, subDimX, ox, String(H));
    dimV(bB, bB + sD, subDimX, bL, String(D));
    dimV(bB + sD, oy + sFlatBodyH, subDimX, bL, flba.toFixed(1));
  }
  ctx.restore();
}

// ============================================================
// FLAT PATTERN: DOOR
// ============================================================
function drawFlatDoor() {
  if (FLAT_MODE === 'off' || !SHOW_DOOR) return;
  const flatY = MARGIN + 25;
  const ox = flatDoorX, oy = flatY;
  const sFlBa = sFL + sBA;
  const flba = FLANGE + BA;
  const totalW = DOOR_W + 2 * flba;
  const totalH = DOOR_H + 2 * flba;
  ctx.save();

  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Развёртка двери', ox + sFlatDoorW / 2, oy - 15);

  ctx.lineWidth = 2; ctx.strokeStyle = '#222';
  rect(ox, oy, sFlatDoorW, sFlatDoorH);

  // Bend lines (rectangle inside showing where flanges fold)
  ctx.lineWidth = 0.9; ctx.strokeStyle = '#c00';
  ctx.setLineDash([12, 4, 2, 4]);
  line(ox + sFlBa, oy, ox + sFlBa, oy + sFlatDoorH);
  line(ox + sFlatDoorW - sFlBa, oy, ox + sFlatDoorW - sFlBa, oy + sFlatDoorH);
  line(ox, oy + sFlBa, ox + sFlatDoorW, oy + sFlBa);
  line(ox, oy + sFlatDoorH - sFlBa, ox + sFlatDoorW, oy + sFlatDoorH - sFlBa);
  ctx.setLineDash([]);

  // Hinge marks (relative to inner door area)
  if (SHOW_HINGES) {
    ctx.lineWidth = 0.7; ctx.strokeStyle = '#555';
    for (let i = 0; i < HINGE_COUNT; i++) {
      const hy = oy + sFlBa + sDoorH * (i + 1) / (HINGE_COUNT + 1);
      ctx.setLineDash([2, 2]);
      line(ox + sFlBa - 6, hy, ox + sFlBa + 12, hy);
      ctx.setLineDash([]);
      ctx.fillStyle = '#999';
      filledCircle(ox + sFlBa + 3, hy, 2);
    }
  }

  // Handle/lock marks
  if (SHOW_HANDLE) {
    ctx.lineWidth = 0.6; ctx.strokeStyle = '#666';
    const hx = ox + sFlatDoorW - sFlBa - 16;
    const hy = oy + sFlBa + sDoorH / 2;
    line(hx - 5, hy, hx + 12, hy);
    line(hx + 3, hy - 8, hx + 3, hy + 8);
  }

  // Ventilation zone
  const vW = sDoorW * 0.45;
  const vX = ox + sFlBa + (sDoorW - vW) / 2;
  const vTop = oy + sFlatDoorH - sFlBa - 50;
  const vH = VENT_SLOTS * 7;
  if (VENT_SLOTS > 0) {
    ctx.lineWidth = 0.5; ctx.strokeStyle = '#999';
    dashedRect(vX, vTop, vW, vH, [4, 3]);
  }

  // Dimensions: total blank size
  dimV(oy, oy + sFlatDoorH, ox - DIM_OFFSET, ox, totalH.toFixed(1));
  dimH(ox, ox + sFlatDoorW, oy + sFlatDoorH + DIM_OFFSET * 0.5, oy + sFlatDoorH, totalW.toFixed(1));

  ctx.restore();
}

// ============================================================
// FLAT PATTERN: MOUNTING PANEL
// ============================================================
function drawFlatPanel() {
  if (FLAT_MODE === 'off' || !SHOW_PANEL) return;
  const flatY = MARGIN + 25;
  const ox = flatPanelX, oy = flatY;
  ctx.save();
  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Развёртка панели', ox + sPanelW / 2, oy - 15);
  ctx.lineWidth = 2; ctx.strokeStyle = '#222';
  rect(ox, oy, sPanelW, sPanelH);
  ctx.lineWidth = 0.8; ctx.strokeStyle = '#666';
  const hi = 12, hr = 3;
  const holes = [
    [ox + hi, oy + hi], [ox + sPanelW - hi, oy + hi],
    [ox + hi, oy + sPanelH - hi], [ox + sPanelW - hi, oy + sPanelH - hi]
  ];
  for (const [cx, cy] of holes) {
    circle(cx, cy, hr); filledCircle(cx, cy, 1);
    line(cx - hr - 3, cy, cx + hr + 3, cy);
    line(cx, cy - hr - 3, cx, cy + hr + 3);
  }
  dimV(oy, oy + sPanelH, ox - DIM_OFFSET, ox, String(PANEL_H));
  dimH(ox, ox + sPanelW, oy + sPanelH + DIM_OFFSET * 0.5, oy + sPanelH, String(PANEL_W));
  ctx.restore();
}

// ============================================================
// FLAT PATTERN: FLOOR (U-mode only)
// ============================================================
function drawFlatFloor() {
  if (FLAT_MODE !== 'u') return;
  const ox = flatFloorX, oy = flatRow2Y;
  const sFlBa = sFL + sBA;
  const flba = FLANGE + BA;
  const totalW = W + 2 * flba;
  const totalH = D + 2 * flba;
  ctx.save();

  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Дно', ox + sTopW / 2, oy - 15);

  ctx.lineWidth = 2; ctx.strokeStyle = '#222';
  rect(ox, oy, sTopW, sTopH);

  // Bend lines
  ctx.lineWidth = 0.9; ctx.strokeStyle = '#c00';
  ctx.setLineDash([12, 4, 2, 4]);
  line(ox + sFlBa, oy, ox + sFlBa, oy + sTopH);
  line(ox + sTopW - sFlBa, oy, ox + sTopW - sFlBa, oy + sTopH);
  line(ox, oy + sFlBa, ox + sTopW, oy + sFlBa);
  line(ox, oy + sTopH - sFlBa, ox + sTopW, oy + sTopH - sFlBa);
  ctx.setLineDash([]);

  dimH(ox, ox + sTopW, oy + sTopH + DIM_OFFSET * 0.5, oy + sTopH, totalW.toFixed(1));
  dimV(oy, oy + sTopH, ox - DIM_OFFSET, ox, totalH.toFixed(1));
  ctx.restore();
}

// ============================================================
// FLAT PATTERN: CEILING (U-mode only)
// ============================================================
function drawFlatCeiling() {
  if (FLAT_MODE !== 'u') return;
  const ox = flatCeilX, oy = flatRow2Y;
  const sFlBa = sFL + sBA;
  const flba = FLANGE + BA;
  const totalW = W + 2 * flba;
  const totalH = D + 2 * flba;
  ctx.save();

  ctx.font = 'bold 16px GOST B, sans-serif';
  ctx.fillStyle = '#222'; ctx.textAlign = 'center';
  ctx.fillText('Крышка', ox + sTopW / 2, oy - 15);

  ctx.lineWidth = 2; ctx.strokeStyle = '#222';
  rect(ox, oy, sTopW, sTopH);

  // Bend lines
  ctx.lineWidth = 0.9; ctx.strokeStyle = '#c00';
  ctx.setLineDash([12, 4, 2, 4]);
  line(ox + sFlBa, oy, ox + sFlBa, oy + sTopH);
  line(ox + sTopW - sFlBa, oy, ox + sTopW - sFlBa, oy + sTopH);
  line(ox, oy + sFlBa, ox + sTopW, oy + sFlBa);
  line(ox, oy + sTopH - sFlBa, ox + sTopW, oy + sTopH - sFlBa);
  ctx.setLineDash([]);

  // Cable holes (inside bend zone)
  ctx.lineWidth = 0.6; ctx.strokeStyle = '#999'; ctx.setLineDash([3, 2]);
  const innerW = sTopW - 2 * sFlBa;
  const cS = innerW / (CABLE_HOLES + 1);
  for (let i = 0; i < CABLE_HOLES; i++) circle(ox + sFlBa + cS * (i + 1), oy + sTopH / 2, 7);
  ctx.setLineDash([]);

  dimH(ox, ox + sTopW, oy + sTopH + DIM_OFFSET * 0.5, oy + sTopH, totalW.toFixed(1));
  dimV(oy, oy + sTopH, ox - DIM_OFFSET, ox, totalH.toFixed(1));
  ctx.restore();
}

// ============================================================
// CANVAS SIZE CALCULATIONS
// ============================================================
function getDrawingSize() {
  const row1W = isoX + sW + dxDepth + MARGIN;
  const row1H = Math.max(frontY + sH + DIM_OFFSET*2 + 35, isoY + sH + 45);
  let tw = row1W;
  let th = row1H;
  const hasRow2 = SHOW_DOOR || SHOW_PANEL || (NOTES_TEXT && NOTES_TEXT.trim());
  if (hasRow2) {
    const maxRow2H = Math.max(
      SHOW_DOOR ? sDoorH : 0,
      SHOW_PANEL ? sPanelH : 0,
      (NOTES_TEXT && NOTES_TEXT.trim()) ? getNotesHeight() + 25 : 0
    );
    th = row2Y + maxRow2H + DIM_OFFSET + 30;
    let row2Right = MARGIN;
    if (SHOW_DOOR) row2Right = doorViewX + sDoorW + DIM_OFFSET;
    if (SHOW_PANEL) row2Right = Math.max(row2Right, panelViewX + sPanelW + DIM_OFFSET);
    if (NOTES_TEXT && NOTES_TEXT.trim()) row2Right = Math.max(row2Right, notesX + NOTES_W);
    row2Right += MARGIN;
    tw = Math.max(tw, row2Right);
  }
  return [tw, th];
}

function getFlatSize() {
  if (FLAT_MODE === 'off') return [0, 0];
  const flatY = MARGIN + 25;
  const row1MaxH = Math.max(sFlatBodyH, SHOW_DOOR ? sFlatDoorH : 0, SHOW_PANEL ? sPanelH : 0);
  let th = flatY + row1MaxH + DIM_OFFSET * 1.5 + 30;
  let tw = flatBodyX + sFlatBodyW + DIM_OFFSET;
  if (SHOW_DOOR) tw = Math.max(tw, flatDoorX + sFlatDoorW + DIM_OFFSET);
  if (SHOW_PANEL) tw = Math.max(tw, flatPanelX + sPanelW + DIM_OFFSET);

  if (FLAT_MODE === 'u') {
    th = flatRow2Y + sTopH + DIM_OFFSET + 30;
    tw = Math.max(tw, flatCeilX + sTopW + DIM_OFFSET);
  }

  tw += MARGIN;
  return [tw, th];
}

// ============================================================
// RENDER FUNCTIONS
// ============================================================
function renderDrawing(tw, th) {
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, tw, th);
  ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
  roundRect(3, 3, tw-6, th-6, 4); ctx.stroke();
  ctx.fillStyle = '#555'; ctx.font = '13px GOST B, sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('rd1.io — габаритный чертёж (размеры в мм)', tw/2, th-8);
  drawFront();
  drawSide();
  drawIso();
  drawDoor();
  drawPanel();
  drawNotes();
}

function renderFlat(tw, th) {
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, tw, th);
  ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
  roundRect(3, 3, tw-6, th-6, 4); ctx.stroke();
  ctx.fillStyle = '#555'; ctx.font = '13px GOST B, sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('rd1.io — развёртки деталей (размеры в мм)', tw/2, th-8);
  drawFlatBody();
  drawFlatDoor();
  drawFlatPanel();
  drawFlatFloor();
  drawFlatCeiling();
}

function redraw() {
  readInputs();
  const dpr = window.devicePixelRatio || 1;

  // Drawing sheet
  ctx = ctxDraw;
  const [dw, dh] = getDrawingSize();
  cvsDraw.width = dw * dpr;
  cvsDraw.height = dh * dpr;
  cvsDraw.style.width = dw + 'px';
  cvsDraw.style.height = dh + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  renderDrawing(dw, dh);

  // Flat patterns sheet
  if (FLAT_MODE !== 'off') {
    ctx = ctxFlat;
    const [fw, fh] = getFlatSize();
    cvsFlat.width = fw * dpr;
    cvsFlat.height = fh * dpr;
    cvsFlat.style.width = fw + 'px';
    cvsFlat.style.height = fh + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    renderFlat(fw, fh);
    cvsFlat.style.display = '';
  } else {
    cvsFlat.style.display = 'none';
  }
}

// ============================================================
// PDF DOWNLOAD
// ============================================================
function buildPDF(canvasEl, ctxRef, tw, th, renderFn, filename) {
  return async function() {
    const btn = this;
    btn.disabled = true;
    const origText = btn.textContent;
    btn.textContent = '...';
    try {
      readInputs();
      ctx = ctxRef;
      const DPR = 3;
      canvasEl.width = tw * DPR;
      canvasEl.height = th * DPR;
      ctx.save();
      ctx.scale(DPR, DPR);
      renderFn(tw, th);
      ctx.restore();

      const jpegBlob = await new Promise(r => canvasEl.toBlob(r, 'image/jpeg', 0.98));
      const jpegArr = new Uint8Array(await jpegBlob.arrayBuffer());
      const pw = canvasEl.width, ph = canvasEl.height;

      redraw();

      const f = n => n.toFixed(2);
      const pageW = Math.max(842, tw * 0.75);
      const pageH = Math.max(595, th * 0.75);
      const margin = 18;
      const sc = Math.min((pageW - 2*margin) / pw, (pageH - 2*margin) / ph);
      const iw = pw * sc, ih = ph * sc;
      const ix = (pageW - iw) / 2, iy = (pageH - ih) / 2;
      const cs = 'q ' + f(iw) + ' 0 0 ' + f(ih) + ' ' + f(ix) + ' ' + f(iy) + ' cm /I Do Q';
      const enc = new TextEncoder();
      const parts = []; const offsets = []; let pos = 0;
      function w(s) { const b = enc.encode(s); parts.push(b); pos += b.length; }
      function wb(a) { parts.push(a); pos += a.length; }
      function mark(n) { offsets[n] = pos; }
      w('%PDF-1.4\n%\xC0\xC1\xC2\xC3\n');
      mark(1); w('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n');
      mark(2); w('2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n');
      mark(3); w('3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 '
        + f(pageW) + ' ' + f(pageH) + '] /Contents 4 0 R /Resources << /XObject << /I 5 0 R >> >> >>\nendobj\n');
      mark(4); w('4 0 obj\n<< /Length ' + cs.length + ' >>\nstream\n' + cs + '\nendstream\nendobj\n');
      mark(5); w('5 0 obj\n<< /Type /XObject /Subtype /Image /Width ' + pw
        + ' /Height ' + ph + ' /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length '
        + jpegArr.length + ' >>\nstream\n');
      wb(jpegArr);
      w('\nendstream\nendobj\n');
      const xrefPos = pos;
      w('xref\n0 6\n0000000000 65535 f \n');
      for (let i = 1; i <= 5; i++) w(String(offsets[i]).padStart(10, '0') + ' 00000 n \n');
      w('trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n' + xrefPos + '\n%%EOF\n');
      const total = parts.reduce((s, p) => s + p.length, 0);
      const result = new Uint8Array(total);
      let off = 0;
      for (const p of parts) { result.set(p, off); off += p.length; }
      const blob = new Blob([result], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 5000);
    } catch(e) {
      alert('PDF error: ' + e.message);
      redraw();
    }
    btn.disabled = false;
    btn.textContent = origText;
  };
}

document.getElementById('btnPdfDrawing').addEventListener('click', function() {
  readInputs();
  ctx = ctxDraw;
  const [tw, th] = getDrawingSize();
  buildPDF(cvsDraw, ctxDraw, tw, th, renderDrawing, 'rd1io-drawing.pdf').call(this);
});

document.getElementById('btnPdfFlat').addEventListener('click', function() {
  readInputs();
  ctx = ctxFlat;
  const [tw, th] = getFlatSize();
  if (tw === 0) { alert('Развёртки отключены'); return; }
  buildPDF(cvsFlat, ctxFlat, tw, th, renderFlat, 'rd1io-flat.pdf').call(this);
});

// ============================================================
// LABELS
// ============================================================
function setLabels() {
  document.getElementById('title').textContent = 'Электрошкаф rd1.io';
  document.getElementById('secGab').textContent = 'Габариты';
  document.getElementById('secDet').textContent = 'Детали';
  document.getElementById('lbW').textContent = 'Ширина';
  document.getElementById('lbH').textContent = 'Высота';
  document.getElementById('lbD').textContent = 'Глубина';
  document.getElementById('lbThickness').textContent = 'Толщина металла';
  document.getElementById('lbFlange').textContent = 'Фланец';
  document.getElementById('lbDoorInset').textContent = 'Отступ двери';
  document.getElementById('lbHandleH').textContent = 'Высота ручки';
  document.getElementById('lbVentSlots').textContent = 'Вентиляция';
  document.getElementById('lbCableHoles').textContent = 'Кабельные вводы';
  document.getElementById('lbMountGap').textContent = 'Отступ монтажной панели';
  document.getElementById('lbHinges').textContent = 'Количество петель';
  ['uW','uH','uD','uThickness','uFlange','uDoorInset','uHandleH','uMountGap'].forEach(
    id => document.getElementById(id).textContent = 'мм'
  );
  ['uVentSlots','uCableHoles','uHinges'].forEach(
    id => document.getElementById(id).textContent = 'шт'
  );
  document.getElementById('secShow').textContent = 'Отобразить';
  document.getElementById('lbShowDoor').textContent = 'Дверь';
  document.getElementById('lbShowPanel').textContent = 'Монтажная панель';
  document.getElementById('lbShowHandle').textContent = 'Ручка и замок';
  document.getElementById('lbShowHinges').textContent = 'Петли';
  document.getElementById('lbFlatMode').textContent = 'Развёртки';
  document.getElementById('secNotes').textContent = 'Указания';
  document.getElementById('btnPdfDrawing').textContent = 'Скачать чертёж PDF';
  document.getElementById('btnPdfFlat').textContent = 'Скачать развёртки PDF';
}
setLabels();

// ============================================================
// LOCALSTORAGE PERSISTENCE
// ============================================================
const STORAGE_KEY = 'rd1box_settings';
const numberIds = ['inW','inH','inD','inThickness','inFlange','inDoorInset','inHandleH','inVentSlots','inCableHoles','inMountGap','inHinges'];
const checkIds = ['chkDoor','chkPanel','chkHandle','chkHinges'];

function saveSettings() {
  const data = {};
  numberIds.forEach(id => data[id] = document.getElementById(id).value);
  checkIds.forEach(id => data[id] = document.getElementById(id).checked);
  data.selFlat = document.getElementById('selFlat').value;
  data.taNotes = document.getElementById('taNotes').value;
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch(e) {}
}

function loadSettings() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const data = JSON.parse(raw);
    numberIds.forEach(id => { if (data[id] !== undefined) document.getElementById(id).value = data[id]; });
    checkIds.forEach(id => { if (data[id] !== undefined) document.getElementById(id).checked = data[id]; });
    if (data.selFlat !== undefined) document.getElementById('selFlat').value = data.selFlat;
    if (data.taNotes !== undefined) document.getElementById('taNotes').value = data.taNotes;
  } catch(e) {}
}

loadSettings();

document.querySelectorAll('#sidebar input[type="number"]').forEach(el => {
  el.addEventListener('input', () => { saveSettings(); redraw(); });
});
document.querySelectorAll('#sidebar input[type="checkbox"]').forEach(el => {
  el.addEventListener('change', () => { saveSettings(); redraw(); });
});
document.getElementById('selFlat').addEventListener('change', () => { saveSettings(); redraw(); });
document.getElementById('taNotes').addEventListener('input', () => { saveSettings(); redraw(); });

document.fonts.load('16px "GOST B"').then(() => redraw());
</script>
</body>
</html>
